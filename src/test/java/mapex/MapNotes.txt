Map Type
HashMap   -> no order -> fast, mostcommonly used
LinkedHashMap -> insertion order -> preserve order
TreeMap  -> sorted order -> sorted keys
ConcurrentHashMap -> Thread safe -> multithreading

Map<String, Integer> map = new HashMap<>();
Map<String, Integer> ordered = new LinkedHashMap<>();
Map<String, Integer> sorted = new TreeMap<>();


Basic operation of Map
map.put("A", 1);
map.get("A");             // 1
map.containsKey("A");     // true
map.remove("A");
map.size();

Iterating over map
old way  -> not recommended now
for (String key : map.keySet()) {
    System.out.println(key + " = " + map.get(key));
}

new way -> Map.Entry
for (Map.Entry<String, Integer> entry : map.entrySet()) {
               System.out.println(entry.getKey() + " = " + entry.getValue());
           }

Filter Map
map.entrySet().stream()
   .filter(e -> e.getValue() > 50)
   .forEach(e -> System.out.println(e.getKey()));

Collect back to map
Map<String, Integer> filtered =
map.entrySet().stream()
   .filter(e -> e.getValue() > 50)
   .collect(Collectors.toMap(
        Map.Entry::getKey,
        Map.Entry::getValue
   ));

findFirst() vs findAny()
Optional<Map.Entry<String, Integer>> result =
map.entrySet().stream()
   .filter(e -> e.getValue() > 80)
   .findFirst();

findFirst()	-> First element (ordered streams)
findAny()	-> Any element (faster in parallel)


SortByKey
map.entrySet().stream()
   .sorted(Map.Entry.comparingByKey())
   .forEach(System.out::println);

SortByValue
map.entrySet().stream()
   .sorted(Map.Entry.comparingByValue())
   .forEach(System.out::println);


Sort and collect
Map<String, Integer> sorted = map.entrySet().stream()
   .sorted(Map.Entry.comparingByValue())
   .collect(Collectors.toMap(
       Map.Entry::getKey,
       Map.Entry::getValue,
       (a, b) -> a,
       LinkedHashMap::new
   ));

creates immutable map :
Map.Of() ; creates immutable Map
Map.ofEntries() ;creates immutable Map
 Map<String, String> map1 = Map.of(
                "key1", "value1",
                "key2", "value"
        );
 map1.put("key2", "value3"); ->throw UnsupportedOperation exception

 Map<String,String> map2 =Map.ofEntries(
                 Map.entry("key1","value1"),
                 Map.entry("key2","value2")
                 );
 map2.put("key3" ,"value3"); ->throw UnsupportedOperation exception

Computeifpresent,computeifabsent ,compute
  Map<String, String> map1 = new HashMap<>();
         map1.put( "key1", "value1");
         map1.put( "key2", "value2");
         map1.put( "key4", "value4");

         map1.computeIfAbsent("key3", k->"value3");
         System.out.println("map1 value is : " + map1);

         map1.computeIfPresent("key1",(k,v) ->"newvalue_" + v);
         System.out.println("map1 value is : " + map1);

         map1.compute("key4",(k,v) -> (v==null)? "testvalue" : v+"_updated");
         System.out.println("map1 value is : " + map1);


